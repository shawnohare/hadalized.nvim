"""Palette and theme template rendering."""

from pathlib import Path
from typing import Callable, Self

import luadata
from jinja2 import Template, Environment, StrictUndefined, PackageLoader
from loguru import logger
from pydantic import BaseModel

from hadalized.models import Palette
from hadalized.config import Config

type ContextHandler = Callable[[Palette], Palette | dict]
"""A function that can produce context to provide to a template."""


def model_dump_lua(model: BaseModel) -> str:
    return luadata.serialize(model.model_dump(mode="json"), indent="  ")


class Handlers:
    """A collection of palette ContextHandler functions."""

    @staticmethod
    def hex(palette: Palette) -> Palette:
        """Handler that extracts hex values from the palette."""
        return palette.hex()

    @staticmethod
    def lua_hex(palette: Palette) -> dict:
        return {"data": model_dump_lua(palette.hex())}

    @staticmethod
    def css(palette: Palette) -> Palette:
        """Handler that extracts css values from the palette."""
        return palette.css()


package_env = Environment(
    loader=PackageLoader("hadalized"),
    undefined=StrictUndefined,
)
"""Default template loader that looks for templates in the hadalized
package data."""


class ThemeWriter:
    """Responsible for rendering and writing template files for individual
    palettes."""

    def __init__(
        self,
        template: str | Template,
        target_dir: str | Path,
        file_extension: str = "",
        env: Environment = package_env,
        handler: ContextHandler = Handlers.hex,
    ):
        if not file_extension and isinstance(template, Template):
            raise ValueError("File extension must be specified.")
        self.jenv = env
        if isinstance(template, str):
            self.template = self.jenv.get_template(template)
            _, _, ext = template.rpartition(".")
            self.file_extension = ext
        else:
            self.template = template
            self.file_extension = file_extension
        self.target_dir: Path = Path(target_dir)
        self.handler = handler

    def render(self, palette: Palette) -> str:
        """Render the template. Subclasses can override as needed."""
        context = self.handler(palette)
        return self.template.render(context)

    def palette_output_path(self, palette: Palette) -> Path:
        return self.target_dir / f"{palette.name}.{self.file_extension}"

    def write_readme(self):
        path = self.target_dir / "README.md"
        logger.info(f"Writing {path}")
        path.write_text("The files in this directory are autogenerated.")

    def __call__(self, palette: Palette):
        """Write a rendered theme using the input palette."""
        self.target_dir.mkdir(parents=True, exist_ok=True)
        path = self.palette_output_path(palette)
        logger.info(f"Writing {path}")
        path.write_text(self.render(palette))

    @classmethod
    def neovim(cls, config: Config | None = None) -> Self:
        """Create an instance responsible for writing neovim themes."""
        config = config or Config()
        return cls(
            template=config.neovim_theme_template,
            target_dir=config.neovim_target_dir,
            handler=Handlers.lua_hex,
        )

    @classmethod
    def wezterm(cls, config: Config | None = None) -> Self:
        """Create an instance responsible for writing wezterm themes."""
        config = config or Config()
        return cls(
            template=config.wezterm_theme_template,
            target_dir=config.wezterm_target_dir,
            handler=Handlers.hex,
        )
