"""Palette and theme template rendering."""

from pathlib import Path
from typing import TYPE_CHECKING

import luadata
from jinja2 import (
    Environment,
    FileSystemLoader,
    PackageLoader,
    StrictUndefined,
    Template,
    TemplateNotFound,
)
from loguru import logger

from hadalized.models import ContextHandler, Palette

if TYPE_CHECKING:
    from pydantic import BaseModel

    from hadalized.config import Config


class TemplateEnv:
    """Package loaders."""

    package = Environment(
        loader=PackageLoader("hadalized"),
        undefined=StrictUndefined,
        autoescape=True,
    )
    fs = Environment(
        loader=FileSystemLoader(searchpath="./templates"),
        undefined=StrictUndefined,
        autoescape=True,
    )
    _templates: dict[str, Template] = {}

    @classmethod
    def get_template(cls, name: str | Template) -> Template:
        """Get a template"""
        if isinstance(name, Template):
            template = name
        elif (template := cls._templates.get(name)) is None:
            try:
                template = cls.fs.get_template(name)
            except TemplateNotFound:
                template = cls.package.get_template(name)
            cls._templates[name] = template
        return template


def model_dump_lua(model: BaseModel) -> str:
    return luadata.serialize(model.model_dump(mode="json"), indent="  ")


class Handlers:
    """A collection of palette ContextHandler functions."""

    @staticmethod
    def hex(palette: Palette) -> Palette:
        """Handler that extracts hex values from the palette."""
        return palette.hex()

    @staticmethod
    def lua_hex(palette: Palette) -> dict:
        return {"data": model_dump_lua(palette.hex())}

    @staticmethod
    def css(palette: Palette) -> Palette:
        """Handler that extracts css values from the palette."""
        return palette.css()


class PaletteWriter:
    """Responsible for rendering and writing template files for individual
    palettes.
    """

    def __init__(
        self,
        template: str | Template,
        target_dir: str | Path,
        file_extension: str = "",
        handler: ContextHandler = Handlers.hex,
    ):
        if not file_extension and isinstance(template, Template):
            raise ValueError("File extension must be specified.")
        if isinstance(template, str):
            _, _, ext = template.rpartition(".")
            self.file_extension = ext
        else:
            self.file_extension = file_extension
        self.template = TemplateEnv.get_template(template)
        self.target_dir: Path = Path(target_dir)
        self.handler = handler

    def mkdir(self):
        self.target_dir.mkdir(parents=True, exist_ok=True)

    def render(self, data: Palette | Config) -> str:
        """Render the template. Subclasses can override as needed."""
        if isinstance(data, Palette):
            context = self.handler(data)
        else:
            raise NotImplementedError
        return self.template.render(context)

    def output_path(self, palette: Palette) -> Path:
        return self.target_dir / f"{palette.name}.{self.file_extension}"

    def write_readme(self):
        path = self.target_dir / "README.md"
        logger.info(f"Writing {path}")
        path.write_text("The files in this directory are autogenerated.")

    def __call__(self, palette: Palette):
        """Write a rendered theme using the input palette."""
        self.mkdir()
        path = self.output_path(palette)
        logger.info(f"Writing {path}")
        path.write_text(self.render(palette))
