"""Render templates and write outputs."""

from pathlib import Path

from loguru import logger

from hadalized.cache import Cache
from hadalized.config import BuildDirective, Config
from hadalized.models import Template


def write_readme(target_dir: str | Path):
    path = Path(target_dir) / "README.md"
    if not path.exists():
        logger.info(f"Writing {path}")
        path.write_text("The files in this directory are autogenerated.")


class FileWriter:
    """Generate and write files containing hadalized palettes."""

    def __init__(self, config: Config | None = None):
        self.config: Config = config or Config()
        self.cache = Cache(self.config.cache_dir)
        self.build_dir: Path = self.config.build_dir
        self.palettes = list(self.config.palettes.values())

    # def write_palettes(self, directive: BuildDirective) -> list[Path]:
    #     """Handler for when the build directive specifies that one file per
    #     palette should be generated."""
    #     if directive.context_type != "palette":
    #         raise ValueError("Directive must have context_type == 'single'")
    #     template = Template(directive.template)
    #     written: list[Path] = []
    #     target_dir = self.config.build_dir / directive.subdir
    #     target_dir.mkdir(parents=True, exist_ok=True)
    #
    #     for palette in self.config.palettes.values():
    #         path = target_dir / directive.file_name.format(palette=palette)
    #         context = palette.to(directive.color_type)
    #         ok, digest = self.cache.check(path, template, context)
    #
    #         if ok:
    #             logger.info(f"Already generated {path}")
    #             continue
    #
    #         logger.info(f"Writing {path}")
    #         template.write(path, context)
    #         self.cache.add(path, digest)
    #         written.append(path)
    #     return written
    #
    # def write_full(self, directive: BuildDirective) -> list[Path]:
    #     """Handle build directives with full context."""
    #     if directive.context_type != "config":
    #         raise ValueError("Directive must have context_type == 'full'")
    #     template = Template(directive.template)
    #     written: list[Path] = []
    #     target_dir = self.config.build_dir / directive.subdir
    #     target_dir.mkdir(parents=True, exist_ok=True)
    #     path = target_dir / directive.file_name
    #     context = self.config.to(directive.color_type)
    #     ok, digest = self.cache.check(path, template, context)
    #     if ok:
    #         logger.info(f"Already generated {path}")
    #     else:
    #         template.write(path, context)
    #         self.cache.add(path, digest)
    #         written.append(path)
    #     return written

    def write(self, directive: BuildDirective) -> list[Path]:
        template = Template(directive.template)
        target_dir = self.config.build_dir / directive.output_path.parent
        target_dir.mkdir(parents=True, exist_ok=True)
        if directive.context_type == "palette":
            context_nodes = self.palettes
        else:
            context_nodes = [self.config]
        written: list[Path] = []
        for node in context_nodes:
            path = target_dir / directive.output_path.name.format(**node.model_dump())
            context = node.to(directive.color_type)
            ok, digest = self.cache.check(path, template, context)

            if ok:
                logger.info(f"Already generated {path}")
                continue

            logger.info(f"Writing {path}")
            template.write(path, context)
            self.cache.add(path, digest)
            written.append(path)
        return written

    def write_all(self) -> list[Path]:
        """Generate all relevant files."""
        written = []
        for directive in self.config.directives.values():
            written += self.write(directive)
            # match directive.context_type:
            #     case "palette":
            #         written += self.write_palettes(directive)
            #     case "config":
            #         written += self.write_full(directive)
        return written

    def __enter__(self):
        self.cache.connect()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.cache.close()


def main():
    with FileWriter() as writer:
        writer.write_all()


if __name__ == "__main__":
    main()
